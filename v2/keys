#!/usr/bin/env python3.9
# vim: ts=2 sw=2 sts=2 et :
import re, sys, copy, argparse, itertools

def keys( 
  Bins     :"bins are of size n**Bins"     = .5,
  Cols     :"columns to use for inference" = "x",
  Data     :"where to read data"           = "../data/auto2.csv",
  Epsilon  :"small = sd**Epsilon"          = .3,
  FarEnough:"where to look for far things" = .9,
  Goal     :"learning goals: best|rest|other"= "best",
  K        :"bayes low frequency hack"     = 2,
  M        :"bayes low frequency hack"     = 1,
  P        :"distance calculation exponent"= 2,
  Sample   :"#samples to find far things?" = 20,
  Verbose  :"set verbose"                  = False,
  Top      :"focus on this many"           = 20,
  Xample   :"Egs: '-x ls' lists all, '-x all' runs all"= ""):
  """
    ,-_|\     (c) Tim Menzies, 2021, unlicense.org.
   /     \    The delta between things is   
   \_,-._*    simpler than the things.
        v """
  
  #------------------------------------------------------------------
  def optimize(b,r): return b**2/(b+r)
  def monitor(b,r) : return r**2/(b+r)
  def explore(b,r) : return 1/(b+r)
  Goal= dict(best=optimize, rest=monitor, other=explore)[Goal]

  #------------------------------------------------------------------
  class Col(o):
    def __init__(i,at=0, txt="", inits=[]): 
      i.n, i.at, i.txt = 0, at, txt
      i.w = -1 if "-" in txt else 1
      [i.add(x) for x in inits]
    def add(i,x,n=1):
      if x != "?": i.n += 1; x= i.add1(x,n)
      return x

  #------------------------------------------------------------------
  class Skip(Col):
    def __init__(i,**kw):  super().__init__(**kw)
    def add1(i,x,n=1)      : return x

  #------------------------------------------------------------------
  class Sym(Col):
    def __init__(i,**kw): i.has={}; super().__init__(**kw)
    def add1(i,x,n=1)   : inc(i.has,x,n); return  x 
    def dist(i,x,y)     : return 0 if x==y else 1
    def ent(i): 
      return sum(-v/i.n * math.log(v/i.n) for v in i.has.values())
    def merge(i, j):
      k = Sym(at=i.at, txt=i.txt)
      [k.add(x,n) for has in (i.has,j.has) for x, n in has.items()]
      return k
    def merged(i, j):
       k = i.merge(j)
       e1,n1, e2,n2, e,n = i.ent(),i.n, j.ent(),j.n, k.ent(),k.n
       if e1 + e2 < 0.01 or e * .95 < n1 / n * e1 + n2 / n * e2:
         return k
    def bins(i, j):
      for k in (i.has | j.has): 
        yield i.has.get(k,0), True, (i.at, (k,k))
        yield j.has.get(k,0), False,(j.at, (k,k))

  #------------------------------------------------------------------
  class Num(Col):
    def __init__(i,**kw): 
      i._all,i.ok=[],False; super().__init__(**kw)
    def all(i)          : 
      if not i.ok: i.ok=True;i._all.sort(); return i._all
    def span(i): 
      return (first(i.all()), last(i.all()))
    def wide(i,epsilon=0):
      return last(i.all()) - first(i.all()) >= epsilon
    def sd(i):
      a= i.all(); return (per(a,.9) - per(a,.1))/2.56
    def add1(i,x,n)     : 
      x, i.ok = float(x), False  
      for _ in range(n): i._all +=[x] 
      return x
    def norm(i,x): 
      if x=="?": return x
      a= i.all()
      return max(0,min(1,(x-first(a))/(last(a)-first(a)+1E-32)))
    def dist(i,x,y):
      if   x=="?": y= i.norm(y); x= 1 if y<0.5 else 0
      elif y=="?": x= i.norm(x); y= 1 if x<0.5 else 0
      else       : x,y = i.norm(x), y.norm(y)
      return abs(x-y)
    def bins(i, j):
      xy= [(z,True) for z in i._all]+[(z,False) for z in j._all]   
      eps= Epsilon * (i.n*i.sd() + j.n*j.sd()) / (i.n + j.n)
      for ((lo,hi),sym) in bins(xy, epsilon=eps, enough=len(xy)**Bins):
        for klass, n in sym.has.items():
          yield n, klass, (i.at,(lo,hi))

  #------------------------------------------------------------------
  class Row(o):
    def __init__(i,lst,tab=None): i.tab, i.cells = tab, lst
    def dist(i,j):
      d= n= 1E-32
      for col in i.tab.cols[Cols]:
        n += 1
        x,y = i.cells[at], j.cells[at]
        d += 1 if  x=="?" and y=="?" else col.dist(x,y)^P
      return (d/n)^(1/P)
    def far(i,rows):
      tmp= [(dist(i,j),j) for _ in  range(Sample)]
      return per(sorted(tmp, key=forst), FarEnough)

  #----------------------------------------------------------------
  def bins(xy,epsilon=0,enough=30):
    def merge(b4):
      j, tmp, n = 0, [], len(b4)
      while j < n:
        a = b4[j]
        if j < n - 1:
         b = b4[j + 1]
         if cy := a.y.merged(b.y):
           a = o(x=(a.x[0],b.x[1]),y=cy)
           j += 1
        tmp += [a]
        j += 1
      return merge(tmp) if len(tmp) < len(b4) else b4
    #-------------------------
    xy   = sorted(xy, key=first)
    bin  = o(x=Num(), y=Sym())
    bins = [bin]
    for i,(x,y) in enumerate(xy):
      if bin.x.n >= enough:
        if x != b4:
          if i < len(xy) - enough:
            if bin.x.wide(epsilon):
              bin  = o(x=Num(), y=Sym())
              bins += [bin]
      bin.x.add(x)
      bin.y.add(y)
      b4 = x
    return merge([o(bin.x.span(), y=bin.y) for bin in bins])      

  #----------------------------------------------------------------
  class Table(o):
    def __init__(i, inits=[]):
      i.rows = []
      i.cols = o(all=[], names=[], x=[], y=[], klass=None)
      [i.add(x) for x in inits]
    #------------------------
    def klassp(i,x) : return "!" in x
    def skipp(i,x)  : return "?" in x 
    def nump(i,x)   : return x[0].isupper()
    def goalp(i,x)  : return "-" in x or "+" in x or i.klassp(x)
    #------------------------
    def add(i,a): i.data(a) if i.cols.names else i.header(a)
    def clone(i, inits=[]): return Table([[i.cols.names]] + inits)
    def data(i,a):
      a= a.cells if type(a)==Row else a
      a= [col.add(a[col.at]) for col in i.cols.all]
      i.rows += [Row(a, tab=i)]
    def header(i,a):
      i.cols.names= a
      for at,x in enumerate(a):
        new = Skip if i.skipp(x) else (Num if i.nump(x) else Sym)
        new = new(at=at,txt=x)
        i.cols.all += [new]
        if not i.skipp(x): 
          i.cols["y" if i.goalp(x) else "x"] += [new]
          if i.klassp(x): 
            i.cols.klass = new

  #-------------------------------------------------------------------

  #-------------------------------------------------------------------
  def contrasts(here, there, t):
    def val(d): return Goal(like(d,True), like(d,False)),d
    def top(a): return sorted(a, reversed=True,key=first)[:Top]
    def like(d, kl):
      out = prior = (hs[kl] + K) / (n + K*2)
      for at,span in d.items():
        f    = has.get((kl,(at,span)),0)  
        out *= (f + M*prior) / (hs[kl] + M)
      return out
    #-------------------------
    has  = {(kl,(at,(lo,hi))): f
              for col1,col2 in zip(here.cols.x, there.cols.x)
              for f, kl, (at, (lo,hi)) in col1.bins(col2)}
    n    = len(here.rows, there.rows)
    hs   = {True: len(here.rows), False: len(there.rows)}
    solos= [val(dict(at=x)) for at,x in set([z for _,z in has])] 
    ranges={}
    for _,d in top(solos):
      for k in d:
        ranges[k] = ranges.get(k, set()).add( d[k] ) 
    for rule in top([val(d) for d in dict_product(ranges)]):
      print(rule)

  #------------------------------------------------------------------
  class Eg: 
    def ls(): 
      "list  all examples."
      print("\nexamples:")
      for k,f in vars(Eg).items(): 
        if k[0] != "_": print(f"  {k:<14} {f.__doc__}")

    def data(file="../data/vote.csv",goal="democrat"):
      "simple load of data into  a table"
      t= Table(csv(file))
      assert(435 == len(t.rows))
      assert(195 == t.cols.all[1].has['y'])

    def clone(file="../data/vote.csv", k="democrat"):
      "contrast set for files"
      t   = Table(csv(file))
      kl  = t.cols.klass.at
      u,v = t.clone(), t.clone()
      [(u if k==r.cells[kl] else v).add(r) for r in t.rows]

  #------------------------------------------------------------------
  ### main program for keys
  if Xample == "all":
    for k,f in vars(Eg).items():
      if k[0] != "_": print("\n"+k); f()
  else:
    if Xample and Xample in vars(Eg): vars(Eg)[Xample]()

#--------------------------------------------------------------------
#### things that don't use the config vars
### dictionaries 
def inc(d,k,n=1): tmp= d[k]= n + d.get(k,0); return tmp
def has(d,k)    : return d.get(k,0)

def dict_product(d):
  keys = d.keys()
  for p in itertools.product(*d.values()):
    yield dict(zip(keys, p))

#--------------------------------------------------------------------
### lists
def first(a)    : return a[0]
def last(a)     : return a[-1]
def per(a,p=.5) : return a[ p*len(a)//1 ]
def subsets(l):
  out = [[]]
  for x in l: out += [sub + [x] for sub in out]
  return out[1:] 

#--------------------------------------------------------------------
### objects 
class o(object):
  def __init__(i, **k)  : i.__dict__.update(**k)
  def __getitem__(i,k)  : return i.__dict__[k]
  def __setitem__(i,k,v): i.__dict__[k] = v
  def __repr__(i)       : return i.__class__.__name__ + str(
    {k:v for k,v in sorted(i.__dict__.items()) if k[0] != "_"})

#--------------------------------------------------------------------
### files 
def csv(f=None, sep=","):
  def prep(s): return re.sub(r'([\n\t\r ]|#.*)', '', s)
  if f:
    with open(f) as fp:
      for s in fp:
        if s := prep(s): yield s.split(sep)
  else:
    for s in sys.stdin:
      if s := prep(s): yield s.split(sep)

#--------------------------------------------------------------------
### command line options
def cli(f):
  p= argparse.ArgumentParser(prog = "./"+f.__name__,
                     description  =  f.__doc__,
                     formatter_class = argparse.RawTextHelpFormatter)
  for (k,h),b4 in zip(list(f.__annotations__.items()),f.__defaults__):
    if b4==False:
      p.add_argument("-"+(k[0].lower()), dest=k, help=h, 
                     default=False, action="store_true")
    else:
      p.add_argument("-"+(k[0].lower()), dest=k, default=b4, 
                 help= h+" ["+str(b4)+"]", type=type(b4), metavar=k)
  f(**p.parse_args().__dict__)

#--------------------------------------------------------------------
if __name__ == "__main__":
  cli(keys)
